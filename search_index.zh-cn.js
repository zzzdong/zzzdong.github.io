window.searchIndex = [{"url":"https://zzzdong.github.io/blog/","title":"Blog","description":null,"body":"","path":null},{"url":"https://zzzdong.github.io/blog/rust-windows-gnu-env/","title":"搭建Rust的Windows GNU开发环境","description":null,"body":"前言\n在Windows上，使用Rust开发时，官方是推荐MSVC的环境，但是MSVC环境需要VS，或者至少Microsoft C++ 生成工具。这里需要注意的一点，就是它们的许可问题，在我们常用的Community版本中，是有比较多的限制的，它要求在开源项目，或者是非企业环境中。\n这时，gnu版本是一个不错的选择，它相对没有那么多的约束。\n只不过它的安装会有些麻烦。\n安装gnu环境\n\n通过rustup安装rustc。\n\n下载 https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-gnu/rustup-init.exe ，双击安装。使用直接回车默认配置安装即可。\n当已有的rustup的时候，可以：\n\n\n安装mingw-w64开发工具。\n\n根据 https://www.mingw-w64.org/downloads/#w64devkit 的说明，下载安装w64devkit开发工具。\n下载后，运行exe，选择一个目录解压安装。\n配置环境变量，把上面的安装目录的bin目录添加到PATH中。\n\n修正w64devkit的兼容性问题。\n\n上面安装后，运行cargo build可能会报错，出现ld.exe: cannot find -lgcc_eh相似的错误。这时，需要手动修正一下。\n生成一个空的libgcc_eh.a文件。\n\n参考资料\n\nhttps://github.com/stacks-network/stacks-core/pull/5937#issuecomment-2747629024\n\n","path":null},{"url":"https://zzzdong.github.io/blog/retry-grpc-in-rust/","title":"来重试GRPC吧","description":null,"body":"前言\n最近在摸一个etcd的Rust client，很自然地使用tonic来做grpc的请求，但是发现tonic并没有提供一个重试机制，在token失效的时候，无法自动重试，于是就尝试摸索一把，看一看能不能搞定。\n正文\n先来看看tonic的文档，是可以用Interceptor来做拦截器的，里面更是建议用tower机制来做中间件。这两个中间件的实现都有一个问题，就是不能重发数据，因为它们都是在grpc的transport层来做的，而且在transport层已经是只有一个不能Clone的tonic::Request&lt;tonic::body::Body&gt;，所以不能在错误时重发。\n既然在grpc的底层transport太底层了不能重发，那么我们就看再上一层的。\n好啦，我们观察grpc的请求的话，可以看到grpc的client和server交互存在4种模式：\n\nunary\nserver stream\nclient stream\nbidirectional stream\n\n其中unary和server stream都是client发送一个message，然后等待服务器响应的。即发送tonic::Request&lt;prost::Message&gt;，prost::Message通常是一个可clone的struct。我们就可以通过Clone message，然后发送多次。\n在查看tonic的代码时，我们可以找到tonic::client::Grpc，其中它提供了对4种不同的模式发送消息。\n在编程的世界中，任何问题都可以通过增加一个间接的中间层来解决。那么邪恶开始了，直接拷贝抽取tonic::client::Grpc来加一个trait，再实现它。\n\n现在就可以实现GrpcService这个trait，其中底层调用tonic::client::Grpc。\n\n代价来啦，由于是重写了Grpc请求部分，所有tonic_build生成的代码就失效了，需要手动写了。例如：\n\n最后，回到开始需求：为etcd client添加一个自动刷新token的功能。在unary请求时，出现token失效的情况，就重新去申请token，并重新发起请求。\n至于watch这样的streaming的请求，直接简单粗暴地在请求前不管三七二十一的先重新申请token再发送请求。\n编外话\n对具体实现的代码感兴趣的，可以查看我的github。\n","path":null},{"url":"https://zzzdong.github.io/blog/how-a-bad-interpreter/","title":"不专业的代码解释器会有多垃圾","description":null,"body":"启\n前排警告，Rust注意！！！\n上班总是CURD，摸鱼太多，一直没有目标。看到说程序员有三大浪漫：操作系统、编译原理和图形学。作为个不专业的程序员，我只能选择编译原理来摸索一下，来恶补基础知识。于是乎，就有了这坨东西evalit。\n当然啦，也没有这么简单，一开始的时候，是看到了这个expr，得到了启发，觉得可以搞个类似东东来做个脚本工具来方便集成到程序里面，方便一些自定义、可编程的操作。至于现在这坨成果，那就有点离题万里。\n翻开提交记录，赫然看到第一次提交代码是在2023年9月1日。间间断断，有闲心就摸鱼写写，终于在近段时间，能搞出个能用的版本（代码是被强行rebase过的，记录也不完整了）。\n中间写时，没有规划，也没有设计，一直把框架变来变去，也是重构过好几版。就目前的情况，也只能说能跑，至于结果吗，也不知道它会不会跑乱掉。\n总体而言，可以看到一个不专业的程序员，能写出一个多垃圾的解释器。各位看到的话，要引以为鉴，切勿模仿。\n承\n总览上来看，这是一个语法解释器，可以编译一段代码到ByteCode，然后跑在一个基于寄存器的虚拟机上。\n如果各位不怕脏了眼睛，打开这项目，会发现这些：\n语法设计\n说是设计，其实是没有设计，只有抄袭，而且还抄得不对，233。\n首先，一切都是对象？该语法只有一些简单类型：\ntyperust typedescription\nboolbool布尔值\ninti64整型数\nfloatf64浮点数\nstringString字符串\narrayVec数组\nmapHashMap&lt;String, T&gt;映射\n\n再就是运算符：只有简单的：\noperatordescription\n+加法\n-减法\n*乘法\n/除法\n%取余\n==相等\n!=不等\n&lt;小于\n&lt;=小于或等于\n&gt;大于\n&gt;=大于或等于\n&amp;&amp;逻辑与\n||逻辑或\n\n有限的控制流：\ncontrol flowdescription\nif条件\nwhile循环\nfor迭代器\nbreak跳出循环\ncontinue跳过当前循环\nreturn返回\n\n实现\n整体解释器实现，会有几块：\n\n\n语法解析。就是一个parser，解析出AST。使用pest写的。自己手写的词法解析，也不是不行，但是要应对各种语法处理逻辑，估计也写不好，还是直接用pest比较方便，就是要查查文档，对着各种已有的例子抄一抄就行了。\n\n\n语义检查和类型检查。这个没什么好介绍的，其实就是脱裤子放屁啦，这么点的语法解释器，也用不上这个大杀器，其实多余的。问就是AI生成的，代码不是自己写。\n\n\nLowering。话说这个的中文是叫什么？就是把AST转化为IR。对的，这个项目，是搞了奇葩的IR层，其实没有什么意义的，特别是对于解释器来说。\n\n\nCodegen。应该叫代码生成？就是把上面的IR转为为ByteCode。为啥啊，单纯为了照顾坑爹的VM。同时，里面还有个搓搓的寄存器分配器，这个需要特别注意，千万不要去看，因为里面都是坑，没有正确的算法支撑，写的时候折腾最久，一切都是靠磨出来的，只依赖项目几个有限的测试用例来保证一下它可能是符合运行预期的。\n\n\nRuntime。就是上面提到的虚拟机以及围绕它的一些数据结构等等。这个坑爹虚拟机是基于寄存器，里面会模仿x86的一些行为，比如calling convention，函数调用使用压栈入参，函数局部变量使用寄存器和栈。注意啦，这个虚拟机的操作对象都是一个个Object哈，还记得上面说过的一切都是对象么，所有寄存器和栈里面都是Arc&lt;RwLock&lt;Box&lt;dyn Object&gt;&gt;&gt;。嘛，反正也没追求什么性能。\n\n\nGC。哈哈哈，想多了。这坨东西没有设计有垃圾回收，你都看到了，它用的是Arc。所以它没有正确垃圾处理，反正一直不回收也是一种垃圾处理嘛。对了，这样的它是应对了不了循环引用的。使用的时候请注意啦，小心它会一口一口吃掉你的内存。\n\n\n转\n假如看到了上面的说明，都还在看的话，可以说一下这个项目可以做到什么了。\n\n\n它有几个有限的单元测试。里面可以看到，这个解释器可以完成一个简单的fib计算。就是斐波纳契数列的前10个总和会是143。\n\n\n正如scripting的例子里面展示的那样，可以嵌入async的rust里面，满足一些简单脚本功能，调用通过调用rust的暴露进去的方法来完成写逻辑处理。\n\n\n合\n总的来说，作为一个不专业的程序员，写出的这坨糟糕的解释器，暴露了很多问题：\n\n\n首先，项目规划，应该是要有设计，有想法，特别是要有技术支撑。不是科班出身，没有系统学过编译原理这一块的东西，靠着自己折腾，是很难搞的。\n\n\n其次，自身不行，AI来凑。目前来说，AI是能用的，特别用于帮忙梳理思路和补全代码；但是它的能力有限，现在仍然有些问题。等它发展起来，估计我这等混子程序员就要被淘汰了。\n\n\n最后，自己写代码，自己写代码，自己写代码。纸上得来终觉浅，绝知此事要躬行！\n\n\n最后的最后，项目的地址是这个：https://github.com/zzzdong/evalit。\n\nPS：不排除下一步搞一个可以本地运行的native语言。就是用pest解析语法，cranelift生成机器码，mmtk来做垃圾回收，类似Go的模样。\n\n","path":null},{"url":"https://zzzdong.github.io/","title":"","description":null,"body":"","path":null},{"url":"https://zzzdong.github.io/blog/how-a-bad-interpreter/","title":"不专业的代码解释器会有多垃圾","description":null,"body":"启\n前排警告，Rust注意！！！\n上班总是CURD，摸鱼太多，一直没有目标。看到说程序员有三大浪漫：操作系统、编译原理和图形学。作为个不专业的程序员，我只能选择编译原理来摸索一下，来恶补基础知识。于是乎，就有了这坨东西evalit。\n当然啦，也没有这么简单，一开始的时候，是看到了这个expr，得到了启发，觉得可以搞个类似东东来做个脚本工具来方便集成到程序里面，方便一些自定义、可编程的操作。至于现在这坨成果，那就有点离题万里。\n翻开提交记录，赫然看到第一次提交代码是在2023年9月1日。间间断断，有闲心就摸鱼写写，终于在近段时间，能搞出个能用的版本（代码是被强行rebase过的，记录也不完整了）。\n中间写时，没有规划，也没有设计，一直把框架变来变去，也是重构过好几版。就目前的情况，也只能说能跑，至于结果吗，也不知道它会不会跑乱掉。\n总体而言，可以看到一个不专业的程序员，能写出一个多垃圾的解释器。各位看到的话，要引以为鉴，切勿模仿。\n承\n总览上来看，这是一个语法解释器，可以编译一段代码到ByteCode，然后跑在一个基于寄存器的虚拟机上。\n如果各位不怕脏了眼睛，打开这项目，会发现这些：\n语法设计\n说是设计，其实是没有设计，只有抄袭，而且还抄得不对，233。\n首先，一切都是对象？该语法只有一些简单类型：\ntyperust typedescription\nboolbool布尔值\ninti64整型数\nfloatf64浮点数\nstringString字符串\narrayVec数组\nmapHashMap&lt;String, T&gt;映射\n\n再就是运算符：只有简单的：\noperatordescription\n+加法\n-减法\n*乘法\n/除法\n%取余\n==相等\n!=不等\n&lt;小于\n&lt;=小于或等于\n&gt;大于\n&gt;=大于或等于\n&amp;&amp;逻辑与\n||逻辑或\n\n有限的控制流：\ncontrol flowdescription\nif条件\nwhile循环\nfor迭代器\nbreak跳出循环\ncontinue跳过当前循环\nreturn返回\n\n实现\n整体解释器实现，会有几块：\n\n\n语法解析。就是一个parser，解析出AST。使用pest写的。自己手写的词法解析，也不是不行，但是要应对各种语法处理逻辑，估计也写不好，还是直接用pest比较方便，就是要查查文档，对着各种已有的例子抄一抄就行了。\n\n\n语义检查和类型检查。这个没什么好介绍的，其实就是脱裤子放屁啦，这么点的语法解释器，也用不上这个大杀器，其实多余的。问就是AI生成的，代码不是自己写。\n\n\nLowering。话说这个的中文是叫什么？就是把AST转化为IR。对的，这个项目，是搞了奇葩的IR层，其实没有什么意义的，特别是对于解释器来说。\n\n\nCodegen。应该叫代码生成？就是把上面的IR转为为ByteCode。为啥啊，单纯为了照顾坑爹的VM。同时，里面还有个搓搓的寄存器分配器，这个需要特别注意，千万不要去看，因为里面都是坑，没有正确的算法支撑，写的时候折腾最久，一切都是靠磨出来的，只依赖项目几个有限的测试用例来保证一下它可能是符合运行预期的。\n\n\nRuntime。就是上面提到的虚拟机以及围绕它的一些数据结构等等。这个坑爹虚拟机是基于寄存器，里面会模仿x86的一些行为，比如calling convention，函数调用使用压栈入参，函数局部变量使用寄存器和栈。注意啦，这个虚拟机的操作对象都是一个个Object哈，还记得上面说过的一切都是对象么，所有寄存器和栈里面都是Arc&lt;RwLock&lt;Box&lt;dyn Object&gt;&gt;&gt;。嘛，反正也没追求什么性能。\n\n\nGC。哈哈哈，想多了。这坨东西没有设计有垃圾回收，你都看到了，它用的是Arc。所以它没有正确垃圾处理，反正一直不回收也是一种垃圾处理嘛。对了，这样的它是应对了不了循环引用的。使用的时候请注意啦，小心它会一口一口吃掉你的内存。\n\n\n转\n假如看到了上面的说明，都还在看的话，可以说一下这个项目可以做到什么了。\n\n\n它有几个有限的单元测试。里面可以看到，这个解释器可以完成一个简单的fib计算。就是斐波纳契数列的前10个总和会是143。\n\n\n正如scripting的例子里面展示的那样，可以嵌入async的rust里面，满足一些简单脚本功能，调用通过调用rust的暴露进去的方法来完成写逻辑处理。\n\n\n合\n总的来说，作为一个不专业的程序员，写出的这坨糟糕的解释器，暴露了很多问题：\n\n\n首先，项目规划，应该是要有设计，有想法，特别是要有技术支撑。不是科班出身，没有系统学过编译原理这一块的东西，靠着自己折腾，是很难搞的。\n\n\n其次，自身不行，AI来凑。目前来说，AI是能用的，特别用于帮忙梳理思路和补全代码；但是它的能力有限，现在仍然有些问题。等它发展起来，估计我这等混子程序员就要被淘汰了。\n\n\n最后，自己写代码，自己写代码，自己写代码。纸上得来终觉浅，绝知此事要躬行！\n\n\n最后的最后，项目的地址是这个：https://github.com/zzzdong/evalit。\n\nPS：不排除下一步搞一个可以本地运行的native语言。就是用pest解析语法，cranelift生成机器码，mmtk来做垃圾回收，类似Go的模样。\n\n","path":null},{"url":"https://zzzdong.github.io/blog/rust-windows-gnu-env/","title":"搭建Rust的Windows GNU开发环境","description":null,"body":"前言\n在Windows上，使用Rust开发时，官方是推荐MSVC的环境，但是MSVC环境需要VS，或者至少Microsoft C++ 生成工具。这里需要注意的一点，就是它们的许可问题，在我们常用的Community版本中，是有比较多的限制的，它要求在开源项目，或者是非企业环境中。\n这时，gnu版本是一个不错的选择，它相对没有那么多的约束。\n只不过它的安装会有些麻烦。\n安装gnu环境\n\n通过rustup安装rustc。\n\n下载 https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-gnu/rustup-init.exe ，双击安装。使用直接回车默认配置安装即可。\n当已有的rustup的时候，可以：\n\n\n安装mingw-w64开发工具。\n\n根据 https://www.mingw-w64.org/downloads/#w64devkit 的说明，下载安装w64devkit开发工具。\n下载后，运行exe，选择一个目录解压安装。\n配置环境变量，把上面的安装目录的bin目录添加到PATH中。\n\n修正w64devkit的兼容性问题。\n\n上面安装后，运行cargo build可能会报错，出现ld.exe: cannot find -lgcc_eh相似的错误。这时，需要手动修正一下。\n生成一个空的libgcc_eh.a文件。\n\n参考资料\n\nhttps://github.com/stacks-network/stacks-core/pull/5937#issuecomment-2747629024\n\n","path":null},{"url":"https://zzzdong.github.io/blog/retry-grpc-in-rust/","title":"来重试GRPC吧","description":null,"body":"前言\n最近在摸一个etcd的Rust client，很自然地使用tonic来做grpc的请求，但是发现tonic并没有提供一个重试机制，在token失效的时候，无法自动重试，于是就尝试摸索一把，看一看能不能搞定。\n正文\n先来看看tonic的文档，是可以用Interceptor来做拦截器的，里面更是建议用tower机制来做中间件。这两个中间件的实现都有一个问题，就是不能重发数据，因为它们都是在grpc的transport层来做的，而且在transport层已经是只有一个不能Clone的tonic::Request&lt;tonic::body::Body&gt;，所以不能在错误时重发。\n既然在grpc的底层transport太底层了不能重发，那么我们就看再上一层的。\n好啦，我们观察grpc的请求的话，可以看到grpc的client和server交互存在4种模式：\n\nunary\nserver stream\nclient stream\nbidirectional stream\n\n其中unary和server stream都是client发送一个message，然后等待服务器响应的。即发送tonic::Request&lt;prost::Message&gt;，prost::Message通常是一个可clone的struct。我们就可以通过Clone message，然后发送多次。\n在查看tonic的代码时，我们可以找到tonic::client::Grpc，其中它提供了对4种不同的模式发送消息。\n在编程的世界中，任何问题都可以通过增加一个间接的中间层来解决。那么邪恶开始了，直接拷贝抽取tonic::client::Grpc来加一个trait，再实现它。\n\n现在就可以实现GrpcService这个trait，其中底层调用tonic::client::Grpc。\n\n代价来啦，由于是重写了Grpc请求部分，所有tonic_build生成的代码就失效了，需要手动写了。例如：\n\n最后，回到开始需求：为etcd client添加一个自动刷新token的功能。在unary请求时，出现token失效的情况，就重新去申请token，并重新发起请求。\n至于watch这样的streaming的请求，直接简单粗暴地在请求前不管三七二十一的先重新申请token再发送请求。\n编外话\n对具体实现的代码感兴趣的，可以查看我的github。\n","path":null}]